# PostgreSQL

## Типы данных

- `INT` - (integer) целые числа
- `VARCHAR` - (character varying) тип для хранения текстовых строк
- `DECIMAL` - тип данных для записи числовых значений с фиксированной точностью. Для использования этого типа в скобках можно 
указать количество цифр в числе вообще, и  количество знаков 
после точки. К примеру если задать число таким образом `DECIMAL(3,2)`
- `DATE` - тип данных для сохранения дата без временной части. Дату удобно задавать в 
формате YYYY-MM-DD («2024-06-30»).
- `TIMESTAMP` - тип данных хранит дату и время без информации о часовом поясе

## SQL Запросы

### Создание таблицы

Запрос на создание таблицы в общем виде выглядит так:

```sql
CREATE TABLE название_таблицы
(название_столбца1 тип_данных , 
 название_столбца2 тип_данных ,
 .............................
 название_столбцаN тип_данных ,
 атрибуты_таблицы
);
```

Пример создания таблицы:

````sql
CREATE TABLE positions 
(
    id	INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    title	VARCHAR,
    salary	INT NOT NULL 
);

CREATE TABLE persons 
(
    id	INT PRIMARY KEY,
    name	VARCHAR,
    position_id	INT,
    FOREIGN KEY (position_id) REFERENCES positions(id)
);
````

#### Первичный ключ

Может быть составным. Определяет уникальность строки.
Для его создания используются ключевые слова `PRIMARY KEY`.

#### Вторичный ключ

Ссылается на первичный ключ связанной таблицы. Для его Для его 
создания используется конструкция 
`FOREIGN KEY (position_id) REFERENCES positions(id)`, где 
`position_id` - столбец внешнего ключа, а `positions(id)` - название таблицы
и название столбца первичного ключа.

### Редактирование таблицы

1. ALTER TABLE: Основная команда для изменения структуры таблицы.
2. ADD COLUMN: Добавление нового столбца в таблицу.
3. DROP COLUMN: Удаление столбца из таблицы.
4. ALTER COLUMN: Изменение типа данных или других свойств столбца.
5. RENAME COLUMN: Переименование столбца.
6. RENAME TO: Переименование таблицы.

####  Примеры запросов

1. Добавление столбца

 ````sql
 ALTER TABLE positions
 ADD COLUMN award VARCHAR(100);
 ````
2. Переименование столбца

````sql
ALTER TABLE positions
RENAME COLUMN award TO bonus;
````

3. Изменение типа данных столбца

````sql
ALTER TABLE positions
ALTER COLUMN bonus TYPE INT USING bonus::INT;
````

4. Переименование таблицы

````sql
ALTER TABLE positions
RENAME TO job_titles;
````

5. Удаление столбца

````sql
ALTER TABLE job_titles
DROP COLUMN bonus;
````


### Добавление записи в таблицу

Пример запроса:

````sql
INSERT INTO positions (id, title, salary) VALUES
	('1', 'Программист', '1500'),
	('2', 'Юрист', '700'),
	('3', 'HR', '700'),
	('4', 'Дизайнер', '700'),
	('5', 'Маркетолог', '500'),
	('6', 'Data Engineer', '3000');

INSERT INTO persons (id, name, position_id) VALUES
    ('1', 'Владимир', '4'),
    ('2', 'Алёна', '1'),
    ('3', 'Евгений', '5'),
    ('4', 'Артём', '2'),
    ('5', 'Борис', '4'),
    ('6', 'Татьяна', '3');
````

Расшифровка `ВСТАВЬ В (таблицу)  positions в столбцы( id, title, salary) ЗНАЧЕНИЯ (...)`

### Обновление записи в таблице

````sql
UPDATE positions
SET title = 'Халтурщик', salary = '50'
WHERE id = 7;
````

### Удаление записи в таблице

````sql
DELETE FROM positions
WHERE id = 7;
````

### Выборка данных (SELECT)

Общий вид:

````sql
SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]
    [ * | expression [ [ AS ] output_name ] [, ...] ]
    [ FROM from_item [, ...] ]
    [ WHERE condition ]
    [ GROUP BY [ ALL | DISTINCT ] grouping_element [, ...] ]
    [ HAVING condition ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] select ]
    [ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { count | ALL } ]
    [ OFFSET start [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } { ONLY | WITH TIES } ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF table_name [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]
````

````sql
SELECT название_столбца1, название_столбца2, название_столбцаN 
FROM название_таблицы;
````

Пример:
````sql
SELECT * 
FROM positions;
````

Чтобы выбрать все столбцы:
````sql
SELECT * 
FROM название_таблицы;
````

#### Фильтрация выборки (WHERE)

````sql
SELECT title
FROM positions
WHERE salary > 1000;
````

##### Операторы сравнения:
- `=` - сравнение на равенство
- `<>` - сравнение на неравенство
- `!=` - сравнение на неравенство
- `<` - меньше чем
- `>` - больше чем
- `<=` - меньше чем или равно
- `>=` - больше чем или равно
- `LIKE` - сравнивает вхождение
- `IN` - проверяет значение в выборке
- `IS NULL` - проверяет на равенство `NULL`

Условие `LIKE` или `NOT LIKE`  позволяет использовать подстановочные символы (метасимволы) в операторе `WHERE`.
Пример:
````sql
SELECT title, salary
FROM positions
WHERE title LIKE '%Data%';
````

#### Уникальные значения (DISTINCT)
`DISTINCT` — это ключевое слово, которое используется для удаления 
дублирующихся строк из результата запроса.

Пример запроса:
````sql
SELECT DISTINCT(salary)
FROM positions;
````

##### Ограничения и особенности:

- `DISTINCT` применяется ко всему результату строки: Когда используется `DISTINCT`, он 
проверяет уникальность всей строки, если указывается несколько столбцов.

- `DISTINCT` и `NULL`: В SQL `NULL` считается уникальным значением, 
поэтому, если в столбце есть несколько NULL значений, DISTINCT оставит только одно.

- Влияние на производительность: Использование `DISTINCT` 
может замедлить выполнение запроса, особенно на больших наборах данных, 
поскольку требуется дополнительная обработка для удаления дублирующихся строк.


#### Алиасы

Для удобства можно использовать псевдонимы.
````sql
SELECT title, salary AS sal
FROM positions
WHERE title LIKE '%Data%';
````

Ключевое слово AS используется для создания псевдонима. В PostgreSQL можно
использовать проблел без `AS`.

#### Агрегатные функции

- `COUNT()` - для нахождения количества строк в запросе.
- `AVG()` - для нахождения среднего значение.
- `SUM()` - для нахождения суммы значений.
- `MIN()` - для нахождения наименьшего значения.
- `MAX()` - для нахождения наибольшего значения.

#### Сортировка и группировка (ORDER BY, GROUP BY)

##### Сортировка

За сотртировку отвечает конструкция `ORDER BY`. Она имеет два значения
- `ASC` - по возрастанию (по умолчанию)
- `DESC` - по убыванию

Пример:
````sql
SELECT * 
FROM positions
ORDER BY salary DESC, title ASC;
````

##### Группировка 

За группировку отвечает конструкция `GROUP BY`.

Пример:
````sql
SELECT product_id, SUM(quantity) AS total_quantity
FROM orders
GROUP BY product_id;

SELECT order_date,product_id, SUM(quantity) AS total_quantity
FROM orders
GROUP BY order_date, product_id
ORDER BY order_date, product_id;
````

###### Оператор HAVING

`HAVING` — это ключевое слово, которое используется вместе с GROUP BY для фильтрации групп строк, основанных на агрегатных функциях. Оно позволяет применять условия к 
группам данных после их агрегации.

`HAVING` аналогично `WHERE`, но применяется после агрегации, тогда как WHERE применяется до нее.

Использование GROUP BY и HAVING:

- `GROUP BY`: Группирует строки по значениям одного или нескольких столбцов.
- `HAVING`: Фильтрует группы, созданные GROUP BY, на основе условий, содержащих агрегатные функции.

Пример:
````sql
SELECT order_date, product_id, SUM(quantity) AS total_quantity
FROM orders
GROUP BY order_date, product_id
HAVING SUM(quantity) > 2
ORDER BY order_date, product_id;
````

#### Подзапросы
Подзапросы - это запросы, которые включены внутри других запросов и могут 
использоваться для извлечения данных, фильтрации, сравнения и других операций.

Возможно использовать с операторами:
- `WHERE`
- `FROM`
- `SELECT`

Примеры:
````sql
SELECT title, salary
FROM positions
WHERE salary IN (SELECT MAX(salary) FROM positions)

SELECT name,email
FROM customers
WHERE (SELECT COUNT(*) FROM orders WHERE orders.customer_id = customers.customer_id) > 5;;
````

Есть еще один сценарий, о существовании которого необходимо знать. 
Это использование подзапросов в операторе FROM. В операторе FROM подзапросы называются встроенными представлениями (view), то есть результатом уже отобранных по какому-то признаку строк.

В этом случае к результатам подзапроса можно обращаться как к 
обычной таблице, но есть одно условие: результату подзапроса обязательно нужно назначить псевдоним. Если не задать псевдоним, то возникнет ошибка. Псевдоним назначается уже привычным способом используя оператор AS.

```sql
SELECT subquery.product_id, subquery.order_date, MAX(subquery.quantity) AS max_quantity_per_day
FROM (SELECT product_id,order_date,quantity FROM orders WHERE product_id = 2) AS subquery
GROUP BY subquery.product_id, subquery.order_date;
```

### UNION и UNION ALL

Операторы UNION и UNION ALL в SQL используются для объединения результатов двух или более SELECT запросов. Различие между 
ними заключается в обработке дубликатов строк.

- `UNION`: Оператор `UNION` объединяет результаты SELECT запросов и удаляет 
дубликаты строк из объединенного результирующего набора.

Пример:
````sql
SELECT column1 FROM table1
UNION
SELECT column1 FROM table2;
````

- `UNION ALL`: Оператор `UNION ALL` также объединяет результаты SELECT запросов, но не удаляет дубликаты строк. Все строки из каждого запроса включаются в объединенный результирующий набор.

````sql
SELECT column1 FROM table1
UNION ALL
SELECT column1 FROM table2;
````

Различия между `UNION` и `UNION ALL`:

- `UNION` удаляет дубликаты строк, а UNION ALL сохраняет все строки включая дубликаты.
- `UNION` выполняет операцию сортировки для удаления дубликатов, что может потребовать дополнительных ресурсов, в то время как UNION ALL не выполняет сортировку.
- `UNION` возвращает уникальный результирующий набор строк, в то время как UNION ALL может содержать дублирующиеся строки

Важно, чтобы в запросах столбцы были одного типа данных.

### JOIN

Различают несколько видов JOIN:

- `INNER JOIN`
- `LEFT/RIGHT JOIN`
- `FULL JOIN`
- `CROSS JOIN`

#### INNER JOIN

`INNER JOIN` возвращают все строки из нескольких таблиц, где выполняется условие соединения.

````sql
SELECT columns
FROM table1
INNER JOIN table2
ON table1.column = table2.column;

ВЫБЕРИ (эти)столбцы
ИЗ таблицы1
СОЕДИНЕННОЙ (с) таблицей2
ПО ПРИНЦИПУ: столбик из таблицы1 = столбик из таблицы 2;
````

![img.png](img.png)

Примеры запросов:
````sql
SELECT name, title, salary
FROM persons
INNER JOIN positions
ON persons.position_id = positions.id
````

Если использовать только `JOIN` - по умолчанию это `INNER JOIN`

#### LEFT/RIGHT JOIN

Эти виды JOIN классифицируются как внешние и вот почему. Во внешних соединениях одна из 
используемых таблиц остается в 
своем неизменном виде, а из второй подставляются значения удовлетворяющие условиям.

![img_1.png](img_1.png)

Примеры:

```sql
SELECT *
FROM positions LEFT JOIN persons
ON positions.id = persons.position_id
```

![img_2.png](img_2.png)

Какое слово указано вместе с `JOIN`, та таблица и остается полностью в выдаче результатов запроса.

#### FULL JOIN
По сути это LEFT JOIN и RIGHT JOIN выполненные одновременно: присутствуют все строки и из левой и из правой таблицы, там где нет 
соответствия по условию проставлены NULL.

![img_3.png](img_3.png)

````sql
SELECT *
FROM positions FULL JOIN persons
ON positions.id = persons.position_id
````

#### CROSS JOIN

Концепция `CROSS JOIN` довольно проста. Он создает декартово 
произведение двух таблиц, то есть комбинирует каждую строку из одной 
таблицы с каждой строкой из другой таблицы. Это значит, что каждая 
строка из первой таблицы будет объединена с каждой строкой из второй 
таблицы. `CROSS JOIN` полезен, когда необходимо рассмотреть все возможные 
комбинации двух наборов данных.

![img_4.png](img_4.png)

````sql
SELECT *
FROM table1 CROSS JOIN table2;
````

## Оконные функции

Оконные функции (window functions) в SQL - это мощный инструмент 
анализа данных, который позволяет выполнять вычисления на наборе 
строк, связанных с текущей строкой. Они представляют собой специальный 
класс функций, которые могут быть применены к набору строк, но без необходимости 
группировки строк как в случае с агрегатными функциями.

Оконные функции обычно используются для вычисления кумулятивных сумм, 
расчета разницы между текущей строкой и предыдущей, определения ранга 
элемента в упорядоченном наборе данных и других аналитических задач.

**Основные аспекты оконных функций:**
- `Сохранение всех строк`: В отличие от агрегатных функций, которые группируют строки и возвращают одну строку на группу, оконные функции возвращают значение для каждой строки исходного набора данных.
- `Часть результата`: Оконные функции используют ключевое слово `OVER`, чтобы указать набор строк, на которые они будут применяться.
- `Разделение и упорядочение`: Вы можете разделить строки на группы (разделы) и упорядочить их внутри этих групп с помощью ключевых слов `PARTITION BY` и `ORDER BY`.

**Типы оконных функций:**
- Агрегатные оконные функции
- Функции ранжирования
- Функции смещения

**Оконную функцию можно использовать без `(PARTITION BY столбец)` - в таком случае окном будет вся таблица**

### Агрегатные оконные функции

Эти функции выполняют агрегатные вычисления, но в отличие от обычных агрегатных функций, они не группируют строки, а возвращают значение для каждой строки.
Например:
````sql
SELECT order_id, order_date, quantity,
       SUM(quantity) OVER (PARTITION BY order_date) AS daily_total_quantity
FROM orders;
````

В этом запросе окно определяется следующими частями:

`OVER (PARTITION BY order_date)`: Это и есть окно. Оно определяет набор строк, к которому применяется агрегатная функция SUM(). В данном случае строки разбиваются на 
группы (partitions) по значению столбца order_date.

`PARTITION BY order_date` разбивает набор строк на поднаборы, где каждая подгруппа содержит строки с одинаковым значением order_date. В каждой подгруппе вычисляется сумма quantity,
и это значение присваивается каждой строке в этой подгруппе.

![img_5.png](img_5.png)

Отличия от агрегатных функций:
![img_6.png](img_6.png)

````sql
SELECT order_id, order_date, quantity,
       AVG(quantity) OVER (PARTITION BY order_date) AS daily_avg_quantity
FROM orders;

SELECT order_id, order_date, quantity,
       MIN(quantity) OVER (PARTITION BY order_date) AS daily_min_quantity
FROM orders;
````

### Функции ранжирования

Эти функции назначают ранг или позицию строкам в пределах окна.
`ROW_NUMBER()`: Назначает уникальный номер каждой строке в пределах окна.

````sql
SELECT order_id, order_date, quantity,
       ROW_NUMBER() OVER (PARTITION BY order_date ORDER BY quantity DESC) AS row_num
FROM orders;
````

![img_7.png](img_7.png)

`RANK()`: Назначает ранг строкам с возможностью дубликатов (одинаковые значения получают одинаковый ранг, а следующая строка получает ранг с пропуском).

````sql
SELECT order_id, order_date, quantity,
       RANK() OVER (PARTITION BY order_date ORDER BY quantity DESC) AS rank
FROM orders;

SELECT 
    order_id,
    RANK() OVER (ORDER BY quantity * products.price_per_unit DESC) AS order_rank
FROM orders
    INNER JOIN products USING(product_id);
````
![img_8.png](img_8.png)

Оранжевая партицию: тут 2 максимальных значения quantity имеют rank = 1, а следующее 
по порядку значение quantity имеет значение rank не 2, а 3, потому как первых значений 
2 строки, и значение rank = 2 - пропускается.

`DENSE_RANK()`: Назначает ранг строкам без пропусков (одинаковые значения получают одинаковый ранг, 
следующая строка получает следующий ранг без пропуска).

````sql
SELECT order_id, order_date, quantity,
       DENSE_RANK() OVER (PARTITION BY order_date ORDER BY quantity DESC) AS dense_rank
FROM orders;
````

![img_9.png](img_9.png)

`NTILE()`: Разбивает строки на n примерно равных частей и назначает номер каждой части.

````sql
SELECT order_id, order_date, quantity,
       NTILE(4) OVER (ORDER BY order_date) AS quartile
FROM orders;
````

### Функции смещения

Эти функции позволяют получать значения из соседних строк.

`LAG()`: Возвращает значение из предыдущей строки в пределах окна. 
Параметры функции указываются в скобках (столбец и шаг смещения).

````sql
SELECT order_id, order_date, quantity,
       LAG(quantity, 1) OVER (ORDER BY order_date) AS prev_quantity
FROM orders;
````

![img_10.png](img_10.png)

`LEAD()`: Возвращает значение из следующей строки в пределах окна.

````sql
SELECT order_id, order_date, quantity,
       LEAD(quantity, 1) OVER (ORDER BY order_date) AS next_quantity
FROM orders;
````

![img_11.png](img_11.png)

`FIRST_VALUE()`: Возвращает первое значение в пределах окна.

````sql
SELECT order_id, order_date, quantity,
       FIRST_VALUE(quantity) OVER (PARTITION BY order_date) AS first_quantity
FROM orders;
````

![img_12.png](img_12.png)

`LAST_VALUE()`: Возвращает последнее значение в пределах окна.

````sql
SELECT order_id, order_date, quantity,
       LAST_VALUE(quantity) OVER (PARTITION BY order_date) AS last_quantity
FROM orders;
````

**Важное замечание:** Для `LAG` и `LEAD` обязательно использование `ORDER BY`, так как они 
зависят от порядка строк. Для `LAST_VALUE` и `FIRST_VALUE` обязательно использование 
`PARTITION BY`, чтобы определить группы строк в которых собственно и ищем последнее 
и первое значение.

### Функции, работающие с рамками (frames)

Эти функции позволяют задавать рамку (frame) внутри окна, на которую будет распространяться 
вычисление. Ключевые слова `ROWS` и `RANGE` помогают определить рамку.

`ROWS BETWEEN`: Устанавливает рамку на основе числа строк относительно текущей строки.
````sql
SELECT order_id, order_date, quantity,
       SUM(quantity) OVER (ORDER BY order_date ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS sum_around
FROM orders;
````

`RANGE BETWEEN`: Устанавливает рамку на основе значений в строках относительно текущей строки.
````sql
SELECT order_id, order_date, quantity,
       SUM(quantity) OVER (ORDER BY order_date RANGE BETWEEN INTERVAL '1 DAY' PRECEDING AND CURRENT ROW) AS range_sum
FROM orders;
````

### Ограничения оконных функций

- С оконными функциями `DISTINCT` не сработает.
- Нельзя сочетать оконные функции с группировкой.
- Оконные функции, как и агрегирующие функции, нельзя использовать в условиях после WHERE.

## Транзакции

**Команды управления транзакциями:**

- `BEGIN` : Начинает новую транзакцию.
- `COMMIT`: Завершает транзакцию и сохраняет все изменения в базе данных.
- `ROLLBACK TO`: Отменяет транзакцию и откатывает все изменения, сделанные в рамках транзакции.
- `SAVEPOINT`: Создает точку сохранения внутри транзакции, к которой можно вернуться с помощью команды `ROLLBACK TO`


```sql
BEGIN;

-- Уменьшаем баланс счета Alice
UPDATE accounts
SET balance = balance - 200.00
WHERE account_id = 1;

-- Увеличиваем баланс счета Bob
UPDATE accounts
SET balance = balance + 200.00
WHERE account_id = 2;

COMMIT;

BEGIN;
UPDATE accounts SET balance = balance - 200.00
    WHERE customer_name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 200.00
    WHERE customer_name = 'Bob';
-- ошибочное действие... забыть его и использовать счёт Чарли
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 200.00
    WHERE customer_name = 'Charlie';
COMMIT;
```

Основные виды феноменов в транзакциях:

- Грязное чтение (Dirty Read): Одна транзакция видит изменения, сделанные другой транзакцией, которые еще не были зафиксированы (committed). Это может привести к чтению данных, которые могут быть отменены (rolled back).

- Неповторяющееся чтение (Non-repeatable Read): Одна транзакция читает данные дважды и получает разные результаты, потому что другая транзакция изменила данные между этими чтениями.

- Фантомное чтение (Phantom Read): Одна транзакция выполняет повторную выборку набора строк по одному и тому же критерию и получает разные результаты, потому что другая транзакция добавила или удалила строки, соответствующие этому критерию.

- Аномалия сериализации (Serialization Anomaly): Результат успешной фиксации группы параллельно выполняющихся транзакций не совпадает с результатом ни одного из возможных вариантов последовательного выполнения этих транзакций.

- Потерянное обновление (Lost Update): Две транзакции читают одно и то же значение, затем обе транзакции пытаются обновить это значение на основе прочитанного значения. В результате одна из транзакций может перезаписать изменения другой транзакции, что приводит к потере обновлений.

Основные уровни изолированности транзакций:


### Установка уровня изолированности для текущей транзакции

```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- Ваши SQL-запросы здесь

COMMIT;
```

### Установка уровня изолированности для всех транзакций в сессии

```sql
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- Ваши SQL-запросы здесь
```

### Установка уровня изолированности по умолчанию для всех сессий

Вы можете установить уровень изолированности по умолчанию для всех сессий, изменив параметр конфигурации default_transaction_isolation в файле конфигурации PostgreSQL (postgresql.conf).

```
default_transaction_isolation = 'repeatable read'
```

## Индексы

## Оптимизация

- Не использовать `*` в `SELECT` запросах
- Ограничение выборки в `SELECT` запрос с помощью оператора `LIMIT`
- Не использовать `DISTINCT` на больших выборках
- При объединениях запросов `UNION ALL` быстрее чем `UNION` за счет отсутствия сортировки

## Полезные приемы

### Подсчет количества уникальных элементов

````sql
COUNT(DISTINCT(название_столбца))
````

## Работа с датами

### Разница между датами

```sql
SELECT town_to, TIMEDIFF(time_in, time_out) as flight_time
FROM Trip
WHERE town_from = "Paris";
```

### Промежуток между датами






















